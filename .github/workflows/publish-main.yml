name: Publish main (versions + latest + site meta)

on:
  push:
    branches: [ main ]
    paths:
      - "resume*.tex"
      - "resume*.cls"
      - "job-description.txt"
      - "jd/job-description.txt"
      - ".github/workflows/publish-main.yml"
  workflow_dispatch:

permissions:
  contents: write

env:
  # --- User Configuration ---
  ROOT_TEX: resume_faangpath.tex
  SITE_BRANCH: gh-pages

  # --- Tool Configuration ---
  ATS_SCRIPT_PATH: .github/ats/ats_pro.py
  ATS_REQS_FILE: .github/ats/requirements.txt
  ATS_TAXONOMY_PATH: .github/ats/taxonomy.json

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4

      - name: Build PDF
        uses: xu-cheng/latex-action@v3
        with:
          root_file: ${{ env.ROOT_TEX }}

      - name: Resolve Filenames
        id: names
        shell: bash
        run: |
          BASE_NAME="${ROOT_TEX%.tex}"
          echo "pdf_name=${BASE_NAME}.pdf" >> "$GITHUB_OUTPUT"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-atspro-v3-${{ hashFiles(env.ATS_REQS_FILE) }}

      - name: Install ATS dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r "${{ env.ATS_REQS_FILE }}"
          python -m spacy download en_core_web_sm

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Run ATS Analysis for publishing
        shell: bash
        run: |
          set -euo pipefail
          ATS="${{ env.ATS_SCRIPT_PATH }}"
          if [ ! -f "$ATS" ]; then
            echo "ATS script not found at $ATS" >&2
            exit 1
          fi

          # Prefer JD in jd/, fallback to root
          if [ -f "jd/job-description.txt" ]; then
            JD="jd/job-description.txt"
          elif [ -f "job-description.txt" ]; then
            JD="job-description.txt"
          else
            echo "Job description not found (looked for jd/job-description.txt and job-description.txt)" >&2
            exit 1
          fi

          # Taxonomy (optional)
          TAX="${{ env.ATS_TAXONOMY_PATH }}"
          if [ ! -f "$TAX" ]; then
            echo "Taxonomy not found at $TAX (continuing without taxonomy)"; TAX=""
          fi

          echo "Using ATS script: $ATS"
          echo "Using JD file:    $JD"
          [ -n "$TAX" ] && echo "Using taxonomy:  $TAX" || true

          PDF="${{ steps.names.outputs.pdf_name }}"
          if [ ! -f "$PDF" ]; then
            echo "PDF not found: $PDF" >&2
            ls -la || true
            exit 1
          fi

          # Build args
          CMD=( python "$ATS" --pdf "$PDF" --jd "$JD" --out-json "ats-pro-report.json" --out-md "ats-pro-report.md" --out-html "ats-pro-report.html" )
          if [ -n "$TAX" ]; then
            CMD+=( --taxonomy "$TAX" )
          fi

          echo "Running: ${CMD[*]}"
          set +e
          "${CMD[@]}"
          ATS_EXIT=$?
          set -e

          if [ "$ATS_EXIT" -ne 0 ]; then
            echo "NOTE: ATS exited with $ATS_EXIT (likely thresholds/gates not met). Proceeding to publish artifacts."
          fi

          # Ensure outputs exist before moving on
          for f in ats-pro-report.json ats-pro-report.md ats-pro-report.html; do
            if [ ! -f "$f" ]; then
              echo "Missing expected output file: $f" >&2
              exit 1
            fi
          done

      - name: Prep assets for publishing
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build
          cp "${{ steps.names.outputs.pdf_name }}" "build/resume.pdf"
          cp "ats-pro-report.json" "build/ats-pro-report.json"
          echo "shortsha=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"
          echo "dateslug=$(date -u +%Y-%m-%d_%H-%M-%S)" >> "$GITHUB_OUTPUT"

      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.SITE_BRANCH }}
          path: site

      - name: Add new version, update latest, and generate gh.json
        shell: bash
        run: |
          set -euo pipefail
          VERSION_TAG="${{ steps.meta.outputs.dateslug }}-${{ steps.meta.outputs.shortsha }}"
          VERSION_DIR="versions/${VERSION_TAG}"
          mkdir -p "site/${VERSION_DIR}" "site/latest"
          
          cp "build/resume.pdf" "site/${VERSION_DIR}/resume.pdf"
          cp "build/ats-pro-report.json" "site/${VERSION_DIR}/ats-pro-report.json"
          
          # Always copy for latest (avoid symlinks on GH Pages)
          cp "site/${VERSION_DIR}/resume.pdf" "site/latest/resume.pdf"
          # (Optional) also expose latest ATS JSON:
          cp "site/${VERSION_DIR}/ats-pro-report.json" "site/latest/ats-pro-report.json" || true

          (
            cd site
            printf '{ "latest": "%s", "versions": [' "${{ steps.meta.outputs.shortsha }}"
            first=1
            for d in $(ls -1d versions/* 2>/dev/null | sort -r); do
              tag=$(basename "$d")
              score="null"
              if [ -f "$d/ats-pro-report.json" ]; then
                score=$(jq -r .overall_score "$d/ats-pro-report.json" 2>/dev/null || echo "null")
              fi
              if [ $first -eq 0 ]; then printf ', '; fi
              printf '{"tag":"%s", "score":%s}' "$tag" "$score"
              first=0
            done
            printf '] }' > gh.json
          )
          touch site/.nojekyll

      - name: Commit & push to gh-pages
        working-directory: site
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Publish resume version: ${{ steps.meta.outputs.dateslug }}-${{ steps.meta.outputs.shortsha }}" || echo "No changes to commit"
          git push origin ${{ env.SITE_BRANCH }}
